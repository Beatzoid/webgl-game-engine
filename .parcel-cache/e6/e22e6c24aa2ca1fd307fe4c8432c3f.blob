{"mappings":"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","sources":["core/gl/gl.ts","core/gl/glBuffer.ts","core/gl/shader.ts","app.ts","core/engine.ts"],"sourcesContent":["/**\n * The WebGL rendering context\n */\nexport let gl: WebGL2RenderingContext;\n\n/**\n * Responsible for setting up a WebGL renderer\n */\nexport class GLUtilities {\n    /**\n     * Initializes WebGL, optionally using the canvas element id provided\n     * @param elementId The Id of the canvas element\n     */\n    public static initialize(elementId?: string): HTMLCanvasElement {\n        let canvas: HTMLCanvasElement;\n\n        if (elementId) {\n            canvas = document.getElementById(elementId) as HTMLCanvasElement;\n            if (!canvas)\n                throw new Error(\n                    `Cannot find a canvas element named ${elementId}`\n                );\n        } else {\n            canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\n            document.body.appendChild(canvas);\n        }\n\n        gl = canvas.getContext(\"webgl2\") as WebGL2RenderingContext;\n        if (!gl) throw new Error(\"Unable to initialize WebGL\");\n\n        return canvas;\n    }\n}\n","import { gl } from \"./gl\";\n\n/**\n * Represents the information needed for a GLBuffer attribute.\n */\nexport class AttributeInfo {\n    /**\n     *  The location of the attribute.\n     */\n    public location: number | undefined;\n\n    /**\n     * The size (number of elements) in the attribute (i.e Vector3 = 3).\n     */\n    public size: number | undefined;\n\n    /**\n     * The number of elements from the beginning of the Buffer\n     */\n    public offset: number | undefined;\n}\n\n/**\n * Represents a WebGL Buffer\n */\nexport class GlBuffer {\n    private _hasAttributeLocation: boolean = false;\n    private _elementSize: number;\n    private _stride: number;\n    private _buffer: WebGLBuffer;\n\n    private _targetBufferType: number;\n    private _dataType: number;\n    private _mode: number;\n    private _typeSize: number;\n\n    private _data: number[] = [];\n    private _attributes: AttributeInfo[] = [];\n\n    /**\n     * Creates a new Gl Buffer\n     * @param elementSize The size of each element in the buffer\n     * @param dataType The data type of the buffer. Default: `gl.FLOAT`\n     * @param targetBufferType The buffer target type. Can be either `gl.ARRAY_BUFFER` or `gl.ELEMENT_ARRAY_BUFFER`. Default: `gl.ARRAY_BUFFER`\n     * @param mode The drawing mode of this buffer. (i.e. `gl.TRIANGLES` or `gl.LINES`). Defaukt: `gl.TRIANGLES`\n     */\n    public constructor(\n        elementSize: number,\n        dataType: number = gl.FLOAT,\n        targetBufferType: number = gl.ARRAY_BUFFER,\n        mode: number = gl.TRIANGLES\n    ) {\n        this._elementSize = elementSize;\n        this._dataType = dataType;\n        this._targetBufferType = targetBufferType;\n        this._mode = mode;\n\n        // Determine byte size\n        switch (this._dataType) {\n            case gl.FLOAT:\n            case gl.INT:\n            case gl.UNSIGNED_INT:\n                this._typeSize = 4;\n                break;\n\n            case gl.SHORT:\n            case gl.UNSIGNED_SHORT:\n                this._typeSize = 2;\n                break;\n\n            case gl.BYTE:\n            case gl.UNSIGNED_BYTE:\n                this._typeSize = 1;\n                break;\n\n            default:\n                throw new Error(`Unrecognized data type \"${dataType}\"`);\n        }\n\n        this._stride = this._elementSize * this._typeSize;\n        this._buffer = gl.createBuffer()!!;\n    }\n\n    /**\n     * Destroy the Buffer\n     */\n    public destroy(): void {\n        gl.deleteBuffer(this._buffer);\n    }\n\n    /**\n     * Bind the Buffer\n     * @param noramlized Indicates if the data should be normalized. Default: `false`\n     */\n    public bind(noramlized: boolean = false): void {\n        gl.bindBuffer(this._targetBufferType, this._buffer);\n\n        if (this._hasAttributeLocation) {\n            for (let it of this._attributes) {\n                gl.vertexAttribPointer(\n                    it.location!!,\n                    it.size!!,\n                    this._dataType,\n                    noramlized,\n                    this._stride,\n                    it.offset!! * this._typeSize\n                );\n                gl.enableVertexAttribArray(it.location!!);\n            }\n        }\n    }\n\n    /**\n     * Unbind the Buffer\n     */\n    public unbind(): void {\n        for (let it of this._attributes) {\n            gl.disableVertexAttribArray(it.location!!);\n        }\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);\n    }\n\n    /**\n     * Adds an attribute with the provided information to the Buffer\n     * @param info The information to add\n     */\n    public addAttributeLocation(info: AttributeInfo): void {\n        this._hasAttributeLocation = true;\n        this._attributes.push(info);\n    }\n\n    /**\n     * Add data to the Buffer\n     * @param data The data to add\n     */\n    public pushBackData(data: number[]): void {\n        for (const d of data) {\n            this._data.push(d);\n        }\n    }\n\n    /**\n     * Upload the Buffer data to the GPU\n     */\n    public upload(): void {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);\n\n        let bufferData: ArrayBuffer;\n        switch (this._dataType) {\n            case gl.FLOAT:\n                bufferData = new Float32Array(this._data);\n                break;\n\n            case gl.INT:\n                bufferData = new Int32Array(this._data);\n                break;\n\n            case gl.UNSIGNED_INT:\n                bufferData = new Uint32Array(this._data);\n                break;\n\n            case gl.SHORT:\n                bufferData = new Int16Array(this._data);\n                break;\n\n            case gl.UNSIGNED_SHORT:\n                bufferData = new Uint16Array(this._data);\n                break;\n\n            case gl.BYTE:\n                bufferData = new Int8Array(this._data);\n                break;\n\n            case gl.UNSIGNED_BYTE:\n                bufferData = new Uint8Array(this._data);\n                break;\n        }\n\n        gl.bufferData(this._targetBufferType, bufferData!!, gl.STATIC_DRAW);\n    }\n\n    /**\n     * Draw the Buffer\n     */\n    public draw(): void {\n        if (this._targetBufferType === gl.ARRAY_BUFFER) {\n            gl.drawArrays(this._mode, 0, this._data.length / this._elementSize);\n        } else if (this._targetBufferType === gl.ELEMENT_ARRAY_BUFFER) {\n            gl.drawElements(this._mode, this._data.length, this._dataType, 0);\n        }\n    }\n}\n","import { gl } from \"./gl\";\n\n/**\n * Represents a WebGL Shader\n */\nexport class Shader {\n    private _name: string;\n    private _program: WebGLProgram | undefined;\n    private _attributes: { [name: string]: number } = {};\n    private _uniforms: { [name: string]: WebGLUniformLocation } = {};\n\n    /**\n     * Creates a new shader\n     * @param name The name of the shader\n     * @param vertexSource The source of the vertex shader\n     * @param fragmentSource The source of the fragment shader\n     */\n    public constructor(\n        name: string,\n        vertexSource: string,\n        fragmentSource: string\n    ) {\n        this._name = name;\n        const vertexShader = this.loadShader(vertexSource, gl.VERTEX_SHADER);\n        const fragmentShader = this.loadShader(\n            fragmentSource,\n            gl.FRAGMENT_SHADER\n        );\n\n        this.createProgram(vertexShader, fragmentShader);\n\n        this.detectAtttributes();\n        this.detectUniforms();\n    }\n\n    /**\n     * The name of the shader\n     */\n    public get name(): string {\n        return this._name;\n    }\n\n    /**\n     * Gets the location of an attribute with the specified name\n     * @param name The name of the attribute\n     */\n    public getAttributeLocation(name: string): number {\n        if (this._attributes[name] === undefined)\n            throw new Error(\n                `Unable to find an attribute named \"${name}\" in shader \"${this._name}\"`\n            );\n\n        return this._attributes[name];\n    }\n\n    /**\n     * Gets the location of an uniform with the specified name\n     * @param name The name of the uniform\n     */\n    public getUniformLocation(name: string): WebGLUniformLocation {\n        if (this._uniforms[name] === undefined)\n            throw new Error(\n                `Unable to find an uniform named \"${name}\" in shader \"${this._name}\"`\n            );\n\n        return this._uniforms[name];\n    }\n\n    /**\n     * Use this shader\n     */\n    public use(): void {\n        gl.useProgram(this._program!!);\n    }\n\n    private loadShader(source: string, shaderType: number): WebGLShader {\n        let shader: WebGLShader = gl.createShader(shaderType) as WebGLShader;\n\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        const error = gl.getShaderInfoLog(shader);\n        if (error)\n            throw new Error(`Error compiling shader \"${this._name}\": ${error}`);\n\n        return shader;\n    }\n\n    private createProgram(\n        vertexShader: WebGLShader,\n        fragmentShader: WebGLShader\n    ): void {\n        this._program = gl.createProgram() as WebGLProgram;\n\n        gl.attachShader(this._program, vertexShader);\n        gl.attachShader(this._program, fragmentShader);\n\n        gl.linkProgram(this._program);\n\n        const error = gl.getProgramInfoLog(this._program);\n        if (error)\n            throw new Error(`Error linking shader \"${this._name}\": ${error}`);\n    }\n\n    private detectAtttributes(): void {\n        const attributeCount = gl.getProgramParameter(\n            this._program!!,\n            gl.ACTIVE_ATTRIBUTES\n        );\n        for (let i = 0; i < attributeCount; i++) {\n            const info: WebGLActiveInfo | null = gl.getActiveAttrib(\n                this._program!!,\n                i\n            );\n            if (!info) break;\n\n            this._attributes[info.name] = gl.getAttribLocation(\n                this._program!!,\n                info.name\n            );\n        }\n    }\n\n    private detectUniforms(): void {\n        const uniformCount = gl.getProgramParameter(\n            this._program!!,\n            gl.ACTIVE_UNIFORMS\n        );\n        for (let i = 0; i < uniformCount; i++) {\n            const info: WebGLActiveInfo | null = gl.getActiveUniform(\n                this._program!!,\n                i\n            );\n            if (!info) break;\n\n            this._uniforms[info.name] = gl.getUniformLocation(\n                this._program!!,\n                info.name\n            )!!;\n        }\n    }\n}\n","import { Engine } from \"./core/engine\";\n\nconst engine: Engine = new Engine();\n\n// The main entry point for the app\nwindow.onload = function () {\n    engine.start();\n};\n\nwindow.onresize = function () {\n    engine.resize();\n};\n","import { gl, GLUtilities } from \"./gl/gl\";\nimport { AttributeInfo, GlBuffer } from \"./gl/glBuffer\";\nimport { Shader } from \"./gl/shader\";\n\nexport class Engine {\n    private _canvas: HTMLCanvasElement | undefined;\n    private _shader: Shader | undefined;\n\n    private _buffer: GlBuffer | undefined;\n\n    /**\n     * Creates a new Engine\n     */\n    public constructor() {}\n\n    /**\n     * Start up the Engine\n     */\n    public start(): void {\n        this._canvas = GLUtilities.initialize();\n        gl.clearColor(0, 0, 0, 1);\n\n        this.loadShaders();\n        this._shader?.use();\n\n        this.createBuffer();\n\n        this.resize();\n        this.loop();\n    }\n\n    /**\n     * Resizes the canvas to fit the window\n     */\n    public resize(): void {\n        if (this._canvas) {\n            this._canvas.width = window.innerWidth;\n            this._canvas.height = window.innerHeight;\n\n            gl.viewport(0, 0, this._canvas.width, this._canvas.height);\n        }\n    }\n\n    private loop(): void {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        // Set uniforms\n        const colorPosition = this._shader?.getUniformLocation(\"u_color\")!!;\n        gl.uniform4f(colorPosition, 1, 0.5, 0, 1);\n\n        this._buffer?.bind();\n        this._buffer?.draw();\n\n        requestAnimationFrame(this.loop.bind(this));\n    }\n\n    private createBuffer(): void {\n        this._buffer = new GlBuffer(3);\n\n        const positionAttribute = new AttributeInfo();\n        positionAttribute.location = this._shader?.getAttributeLocation(\n            \"a_position\"\n        )!!;\n        positionAttribute.offset = 0;\n        positionAttribute.size = 3;\n        this._buffer.addAttributeLocation(positionAttribute);\n\n        // prettier-ignore\n        const vertices = [\n        //  x  y  z\n            0, 0, 0,\n            0, 0.5, 0,\n            0.5, 0.5, 0\n        ];\n\n        this._buffer.pushBackData(vertices);\n        this._buffer.upload();\n        this._buffer.unbind();\n    }\n\n    private loadShaders(): void {\n        const vertexShaderSource = `\n        attribute vec3 a_position;\n\n        void main() {\n            gl_Position = vec4(a_position, 1.0);\n        }`;\n\n        const fragmentShaderSource = `\n        precision mediump float;\n\n        uniform vec4 u_color;\n\n        void main() {\n            gl_FragColor = u_color;\n        }\n        `;\n\n        this._shader = new Shader(\n            \"basic\",\n            vertexShaderSource,\n            fragmentShaderSource\n        );\n    }\n}\n"],"names":["$e3d27f5c3dc2fe8dba65fbea70838854$export$9474f141dfdb0e16","$b03cf2e3746c65c96d39b379869c6fdb$export$d1752e654c4e05d4","$b03cf2e3746c65c96d39b379869c6fdb$export$27a9faed5bcbf55a","[object Object]","elementSize","dataType","FLOAT","targetBufferType","ARRAY_BUFFER","mode","TRIANGLES","_hasAttributeLocation","_data","_attributes","_elementSize","_dataType","_targetBufferType","_mode","INT","UNSIGNED_INT","_typeSize","SHORT","UNSIGNED_SHORT","BYTE","UNSIGNED_BYTE","Error","_stride","this","_buffer","createBuffer","deleteBuffer","noramlized","bindBuffer","it","vertexAttribPointer","location","size","offset","enableVertexAttribArray","disableVertexAttribArray","info","push","data","d","bufferData","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","Uint8Array","STATIC_DRAW","drawArrays","length","ELEMENT_ARRAY_BUFFER","drawElements","$616fbb2495ee5df786519deced079714$export$2b6a748984e845f3","name1","vertexSource","fragmentSource","_uniforms","_name","vertexShader1","loadShader","VERTEX_SHADER","fragmentShader1","FRAGMENT_SHADER","createProgram","detectAtttributes","detectUniforms","name","undefined","useProgram","_program","source","shaderType","shader","createShader","shaderSource","compileShader","error","getShaderInfoLog","vertexShader","fragmentShader","attachShader","linkProgram","getProgramInfoLog","attributeCount","getProgramParameter","ACTIVE_ATTRIBUTES","i","getActiveAttrib","getAttribLocation","uniformCount","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","$07544fd4e027d29d04b4eb89c0c76e0a$var$engine","_canvas","elementId","canvas","document","getElementById","createElement","body","appendChild","getContext","initialize","clearColor","loadShaders","_shader","use","resize","loop","width","window","innerWidth","height","innerHeight","viewport","clear","COLOR_BUFFER_BIT","colorPosition","uniform4f","bind","draw","requestAnimationFrame","positionAttribute","getAttributeLocation","addAttributeLocation","pushBackData","upload","unbind","onload","start","onresize"],"version":3,"file":"index.HASH_REF_9ba7065a1dfaa656834cab6d60c2d3c1.js.map"}