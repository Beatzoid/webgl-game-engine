var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Represents the information needed for a GLBuffer attribute.
 */ parcelHelpers.export(exports, "AttributeInfo", ()=>AttributeInfo
);
/**
 * Represents a WebGL Buffer
 */ parcelHelpers.export(exports, "GlBuffer", ()=>GlBuffer
);
var _gl = require("./gl");
class AttributeInfo {
}
class GlBuffer {
    /**
     * Creates a new Gl Buffer
     * @param elementSize The size of each element in the buffer
     * @param dataType The data type of the buffer. Default: `gl.FLOAT`
     * @param targetBufferType The buffer target type. Can be either `gl.ARRAY_BUFFER` or `gl.ELEMENT_ARRAY_BUFFER`. Default: `gl.ARRAY_BUFFER`
     * @param mode The drawing mode of this buffer. (i.e. `gl.TRIANGLES` or `gl.LINES`). Defaukt: `gl.TRIANGLES`
     */ constructor(elementSize, dataType = _gl.gl.FLOAT, targetBufferType = _gl.gl.ARRAY_BUFFER, mode = _gl.gl.TRIANGLES){
        this._hasAttributeLocation = false;
        this._data = [];
        this._attributes = [];
        this._elementSize = elementSize;
        this._dataType = dataType;
        this._targetBufferType = targetBufferType;
        this._mode = mode;
        // Determine byte size
        switch(this._dataType){
            case _gl.gl.FLOAT:
            case _gl.gl.INT:
            case _gl.gl.UNSIGNED_INT:
                this._typeSize = 4;
                break;
            case _gl.gl.SHORT:
            case _gl.gl.UNSIGNED_SHORT:
                this._typeSize = 2;
                break;
            case _gl.gl.BYTE:
            case _gl.gl.UNSIGNED_BYTE:
                this._typeSize = 1;
                break;
            default:
                throw new Error(`Unrecognized data type "${dataType}"`);
        }
        this._stride = this._elementSize * this._typeSize;
        this._buffer = _gl.gl.createBuffer();
    }
    /**
     * Destroy the Buffer
     */ destroy() {
        _gl.gl.deleteBuffer(this._buffer);
    }
    /**
     * Bind the Buffer
     * @param noramlized Indicates if the data should be normalized. Default: `false`
     */ bind(noramlized = false) {
        _gl.gl.bindBuffer(this._targetBufferType, this._buffer);
        if (this._hasAttributeLocation) for (let it of this._attributes){
            _gl.gl.vertexAttribPointer(it.location, it.size, this._dataType, noramlized, this._stride, it.offset * this._typeSize);
            _gl.gl.enableVertexAttribArray(it.location);
        }
    }
    /**
     * Unbind the Buffer
     */ unbind() {
        for (let it of this._attributes)_gl.gl.disableVertexAttribArray(it.location);
        _gl.gl.bindBuffer(_gl.gl.ARRAY_BUFFER, this._buffer);
    }
    /**
     * Adds an attribute with the provided information to the Buffer
     * @param info The information to add
     */ addAttributeLocation(info) {
        this._hasAttributeLocation = true;
        this._attributes.push(info);
    }
    /**
     * Add data to the Buffer
     * @param data The data to add
     */ pushBackData(data) {
        for (const d of data)this._data.push(d);
    }
    /**
     * Upload the Buffer data to the GPU
     */ upload() {
        _gl.gl.bindBuffer(_gl.gl.ARRAY_BUFFER, this._buffer);
        let bufferData;
        switch(this._dataType){
            case _gl.gl.FLOAT:
                bufferData = new Float32Array(this._data);
                break;
            case _gl.gl.INT:
                bufferData = new Int32Array(this._data);
                break;
            case _gl.gl.UNSIGNED_INT:
                bufferData = new Uint32Array(this._data);
                break;
            case _gl.gl.SHORT:
                bufferData = new Int16Array(this._data);
                break;
            case _gl.gl.UNSIGNED_SHORT:
                bufferData = new Uint16Array(this._data);
                break;
            case _gl.gl.BYTE:
                bufferData = new Int8Array(this._data);
                break;
            case _gl.gl.UNSIGNED_BYTE:
                bufferData = new Uint8Array(this._data);
                break;
        }
        _gl.gl.bufferData(this._targetBufferType, bufferData, _gl.gl.STATIC_DRAW);
    }
    /**
     * Draw the Buffer
     */ draw() {
        if (this._targetBufferType === _gl.gl.ARRAY_BUFFER) _gl.gl.drawArrays(this._mode, 0, this._data.length / this._elementSize);
        else if (this._targetBufferType === _gl.gl.ELEMENT_ARRAY_BUFFER) _gl.gl.drawElements(this._mode, this._data.length, this._dataType, 0);
    }
}
